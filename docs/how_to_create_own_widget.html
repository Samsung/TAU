<!DOCTYPE html>
<html>
	<head>
		<base href="">
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<title>TAU</title>
		<meta charset="utf8">
		<meta http-equiv="X-UA-Compatible" content="IE-edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="css/bootstrap.min.css" rel="stylesheet">
		<link href="css/bootstrap-callout.css" rel="stylesheet">
		<link href="js/smartmenus-0.9.7/css/sm-core-css.css" rel="stylesheet">
		<link href="js/smartmenus-0.9.7/css/sm-clean/sm-clean.css" rel="stylesheet">
		<link href="js/google-code-prettify/prettify.css" rel="stylesheet">
		<link href="css/style.css" rel="stylesheet">
	</head>
	<body>
		<nav>
			<ul id="main-menu" class="sm sm-clean">
				<li><a href="index.html">TAU Guide</a></li>
				<li>
					<a href="javascript:void(0);">Working with TAU</a>
					<ul>
						<li><a href="application_visual_layout.html">Application visual Layout</a></li>
						<li><a href="basic_page_routing.html">Basic page routing</a></li>
						<li><a href="introduction_to_widgets.html">Introduction to widgets</a></li>
						<li><a href="using_jquery_with_tau.html">Using jQuery with TAU</a></li>
						<li><a href="framework_profiles.html">Framework profiles</a></li>
						<li><a href="how_to_create_own_widget.html">How to create own widget</a></li>
						<li><a href="how_to_use_globalize.html">How to use globalize</a></li>
						<li><a href="how_to_use_controller.html">How to use controller</a></li>
						<li><a href="how_to_write_declarative.html">How to write use declarative API</a></li>
					</ul>
				</li>
				
				<li>
					<a href="javascript:void(0);">Custom Elements</a>
					<ul>
						<li><a href="customelements/feature.html">Feature overview</a></li>
						<li><a href="customelements/custom_elements_preparation.html">Custom elements preparation</a></li>
						<li><a href="customelements/cehelloword.html">Tutorial for Custom Elements</a></li>
					</ul>
				</li>
				<li>
					<a href="javascript:void(0)">Tutorials</a>
					<ul>
						<li><a href="tutorial_clock.html">Clock</a></li>
						<li><a href="tutorial_notes.html">Notes</a></li>
						<li><a href="tutorial_gallery.html">Gallery</a></li>
					</ul>
				</li>
				<li>
					<a href="javascript:void(0)">Migration Guide</a>
					<ul>
						<li><a href="migration/features_overview.html">Features overview</a></li>
						<li><a href="migration/breaking_changes.html">Breaking changes</a></li>
						<li><a href="migration/switching_apps_to_tau.html">Switching your Apps to TAU</a></li>
					</ul>
				</li>
				<li><a href="api.html">API Docs</a></li>
				<li><a href="https://developer.tizen.org/forums/web-application-development" target="_blank">Forum</a></li>
			</ul>
		</nav>

		<article>
			<h1 id="custom-widget-step-by-step">Custom widget step by step</h1>
<p>The TAU framework has a package of widgets that will be useful for most use
cases in apps. Very often requirements of the application force the developer
to modify, extend widgets or create the new ones requirements.</p>
<p>The API of TAU framework allows creating custom and adding them to the framework
while maintaining the required widget&#39;s structure.</p>
<h2 id="adding-widgets-to-the-framework">Adding widgets to the framework</h2>
<p>Suppose that already we have prepared our widget which we want to add to
the framework, there are two ways to do this.</p>
<h3 id="breaking-the-framework-flow-and-append-the-custom-widget">Breaking the framework flow and append the custom widget</h3>
<ul>
<li>Developer need to prepare the framework startup by setting tau configuration
  <code>autorun</code> on false</li>
<li>Append the custom widget</li>
<li>Resume flow of framework startup.</li>
</ul>
<p>The widget code has to be placed <strong>after</strong> the TAU library.</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var tauConfig = {
        &quot;autorun&quot;: false
    };
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../lib/tau/mobile/js/tau.js&quot; data-build-remove=&quot;false&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/tau/mobile/theme/default/tau.css&quot;&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;./js/MyWidget.js&quot; data-build-remove=&quot;false&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/MyWidget.css&quot;&gt;
&lt;script&gt;
    tau.engine.run();
&lt;/script&gt;
</code></pre><p>Widget&#39;s file</p>
<pre><code class="lang-js">(function (tau) {
    &quot;use strict&quot;;

    // the widget code;

}(tau));
</code></pre>
<h3 id="append-the-custom-widget-on-event-tauinit">Append the custom widget on event <code>tauinit</code></h3>
<p>The <code>tauinit</code> event is the moment when framework has defined all inner
requires and all build in widgets are defined.</p>
<p>In this case widget code has to be placed <strong>before</strong> the TAU library.</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./js/MyWidget.js&quot; data-build-remove=&quot;false&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/MyWidget.css&quot;&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;../lib/tau/mobile/js/tau.js&quot; data-build-remove=&quot;false&quot;&gt;&lt;/script&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;../lib/tau/mobile/theme/default/tau.css&quot;&gt;
</code></pre><pre><code class="lang-js">document.addEventListener(&quot;tauinit&quot;, function (event) {
    &quot;use strict&quot;;
    var tau = event.detail.tau,

    // the widget code;

});
</code></pre>
<h2 id="i-m-widget">I&#39;m widget</h2>
<p>Now we can append custom widget to the TAU and then we can concentrate
of the minimal code required for a widget definition:</p>
<pre><code class="lang-js-mobile(MyWidget-base/index.html)">    var MyWidget = function () {
        // constructor for every instance
    }

    // All widgets have to have the widget&#39;s prototype
    MyWidget.prototype = new tau.widget.BaseWidget();

    tau.engine.defineWidget(
        &quot;MyWidget&quot;,     // widget&#39;s name
        &quot;.my-widget&quot;,   // widget&#39;s selector
        [],             // public jQuery methods
        MyWidget        // constructor
    );
</code></pre>
<p>Three sections are exposed:</p>
<ul>
<li><p>Constructor</p>
<p>  This is the <em>only</em> place to define all widget properties and their default
  values.</p>
</li>
<li><p>Prototype inheritance</p>
<p>  The prototype of each TAU widget has to be BaseWidget provided by TAU engine.
  We can also use any widget constructor inherited from BaseWidget,
  for example this may be a ListView.</p>
</li>
<li><p>Widget&#39;s definition</p>
<p>  This is method of TAU engine which registers all widget in the framework engine.
  The method requires following arguments:</p>
<ul>
<li><p>name</p>
<p>  The name of the widget has to be unique for the framework. The only
  exception is when we want redefine existing widget.</p>
</li>
<li><p>selector</p>
<p>  The parameter determines CSS selector which will be used to find HTML
  elements. Instance of widget will be created for each element.</p>
</li>
<li><p>methods (required only when we want jQuery Mobile like interface)</p>
<p>  Represents which widget&#39;s methods will be publicated by jQuery Mobile
  interface. Several base methods like &quot;destroy&quot;, disable&quot;, &quot;enable&quot;,
  &quot;option&quot;, &quot;refresh&quot;, &quot;value&quot; are inherited from BaseWidget.</p>
</li>
<li><p>constructor</p>
<p>  Widget&#39;s constructor.</p>
</li>
</ul>
</li>
</ul>
<h2 id="i-look-better">I look better</h2>
<p>The most simple widget, as above, does not provide many functionalities than
adding styles on markup. Developer usually needs more sophisticated widget with
complex HTML structure. For this reason we define protected method <code>_build</code>.
Developer should remember about &quot;underscore&quot; as a prefix before name. It is
contractual way of marking methods as protected because JS does not support
protected methods.</p>
<p>!!!Warning
Base widget has a <code>build</code> method, which can be easily overloaded by a missing _ prefix in the extending widget instance.</p>
<p>Let&#39;s suppose that widget builds a black and white chessboard.
The <code>_build</code> method can be written like as below.</p>
<pre><code class="lang-js-mobile(MyWidget-build/index.html)">(function () {
    var MyWidget = function () {
            // constructor for every instance
        },

        // some a const, variables and methods
        // common for all MyWidget&#39;s instances
        GRID_SIZE = 8;

    // All widgets have to have the widget&#39;s prototype
    MyWidget.prototype = new tau.widget.mobile.BaseWidgetMobile();

    function createChessboardInWrapper(wrapper) {
        var i, cell;

        for (i = 0; i &lt; Math.pow(GRID_SIZE, 2); i++) {
            cell = document.createElement(&quot;div&quot;);
            cell.classList.add(&quot;cell&quot;);
            cell.classList.add(
                // little magic code for creating chessboard;
                ((i + Math.floor(i / GRID_SIZE)) % 2 === 1) ? &quot;white&quot; : &quot;black&quot;
            );
            wrapper.appendChild(cell);
        }
    }

    MyWidget.prototype._build = function (element) {
        var board = document.createElement(&quot;div&quot;);

        element.classList.add(&quot;my-widget&quot;);
        board.classList.add(&quot;container&quot;);

        createChessboardInWrapper(board);

        this._ui.board = board;
        element.appendChild(board);

        return element;
    };

    tau.engine.defineWidget(
        &quot;MyWidget&quot;,     // widget&#39;s name
        &quot;.my-widget&quot;,   // widget&#39;s selector
        [],             // public jQuery methods
        MyWidget        // constructor
    );

})();
</code></pre>
<p>The widget&#39;s css styles can be placed in outer file.</p>
<pre><code class="lang-css">.my-widget .container {
    width: 100vw;
    height: 100vw;
    display: inline-block;
}
.my-widget .cell {
    width: 10vw;
    height: 10vw;
    float: left;
}

.my-widget .cell.white {
    background-color: white;
}
.my-widget .cell.black {
    background-color: black;
}
</code></pre>
<p>The <code>_build</code> method is called by BaseWidget and the element that matches widget
selector is passed as the first argument. Essential reason using of build method
is to rebuild DOM tree, develop new elements or adding new CSS styles to
elements.
If any HTML elements will be used in later work, the good practice is to store
them in the widget. For this purpose in widget&#39;s constructor we can add object
named &quot;_ui&quot; as property of widget instance.</p>
<h2 id="we-are">We are</h2>
<p>Basically each widget can be assembled from any count of other widgets, it is
developer wishes.</p>
<p>Good example for above may be add figure to the our widget of chessboard.
The figure will be button widget.</p>
<pre><code class="lang-js-mobile(MyWidget-addButton/index.html)">function createFigure(icon) {
    var figureElement = document.createElement(&#39;div&#39;);

    figureElement.classList.add(&quot;figure&quot;);
    return tau.widget.Button(figureElement, {
        inline: true,
        style: &quot;circle&quot;,
        icon: icon,
        iconpos: &quot;notext&quot;
    });
}
</code></pre>
<h2 id="i-wait-for-your-order">I wait for your order</h2>
<p>The widget has to look properly but also be responsive for user actions.
For this reason developer should append listeners on actions
of users. In this way the widget will be waiting for events.
This feature is provided in building widget process. Developer should define
protected method <code>_bindEvents</code> which concentrate all attaching of event handlers
in one method.</p>
<pre><code class="lang-js-mobile(MyWidget-bindEvents/index.html)">MyWidget.prototype._bindEvents = function () {
    this._onTap = onTap.bind(null, this);
    this.element.addEventListener(&quot;vclick&quot;, this._onTap, true);
};
</code></pre>
<p>The <code>tap</code> event handler might look like below:</p>
<pre><code class="lang-js-mobile(MyWidget-bindEvents/index.html)">function getDirection(figureElement, x, y) {
    var width = tau.util.DOM.getElementWidth(figureElement),
        height = tau.util.DOM.getElementHeight(figureElement),
        position = tau.util.DOM.getElementOffset(figureElement);

    return {
        x: (position.left + width / 2) &gt; x ? -1 : 1,
        y: (position.top + height / 2) &gt; y ? -1 : 1
    };
}

function onTap(self, event) {
    var directions = getDirection(
            self._ui.figureElement,
            event.clientX,
            event.clientY
        ),
        x = inRange(self.options.figureX + directions.x, 0, 7),
        y = inRange(self.options.figureY + directions.y, 0, 7);

    placeFigure(self._ui.figureElement, x, y);

    self.options.figureX = x;
    self.options.figureY = y;
}
</code></pre>
<p>The important thing at this stage is to save event handlers for listeners
in protected properties of widget instance because later we have to remove those
listeners from widget.</p>
<h2 id="i-will-miss-you-see-you-">I will miss you. See you!</h2>
<p>The developer has to have in mind that his widget may be destroyed in any time.
For that reason he should define in widget protected method <code>_destroy</code>.
The method should takes into account following actions:</p>
<ul>
<li>remove added event handlers,</li>
<li>remove HTML elements added in <code>_build</code> method,</li>
<li>remove or recover the old CSS styles,</li>
<li>erase any cache from widget instances.</li>
</ul>
<pre><code class="lang-js-mobile(MyWidget-destroy/index.html)">function unbindEvents(self) {
    self.element.removeEventListener(&quot;vclick&quot;, self._onTap, true);
};

MyWidget.prototype._destroy = function () {
    unbindEvents(this);
    this.element.removeChild(this._ui.board);
    this._ui.board = null;
};
</code></pre>
<h2 id="i-need-some-things-more-fitted">I need some things more fitted</h2>
<p>Part of widget properties are dependent to additional factors which from
different reasons cannot be included in build method or basically we
do not known yet and they need a some initialization.
From above reasons the widget has a protected method <code>_init</code>. The method has the
to customize the widget in current environment and application state.
Below example shows how to use <code>_init</code> method to place a figure on chessboard.</p>
<pre><code class="lang-js-mobile(MyWidget-init/index.html)">MyWidget.prototype._init = function (element) {
    // set figure position
    placeFigure(this._ui.figureElement, this.options.figureX, this.options.figureY);
};
</code></pre>
<h2 id="widget-configuration">Widget configuration</h2>
<p>In the build flow of widget creation the developer can use method <code>_configure</code>.</p>
<p>Configuration data collected at this moment the developer can use in
<code>_init</code> method.</p>
<pre><code class="lang-js-mobile(MyWidget-configure/index.html)">function saveFigurePosition(x, y) {
    localStorage.setItem(&#39;figurePosition&#39;, JSON.stringify({x: x, y: y}));
}

function loadFigurePosition() {
    var data = localStorage.getItem(&#39;figurePosition&#39;);
    return data ? JSON.parse(data) : null;
}

MyWidget.prototype._configure = function () {
    var options = this.options || {},
        lastPosition = loadFigurePosition();

    if (lastPosition) {
        options.figureX = lastPosition.x;
        options.figureY = lastPosition.y;
    }

    this.options = options;
};
</code></pre>
<p>At this stage of widget instantiate, the process of widget creation,
is searching for attributes which are pushed to widgets options</p>
<p>For example, we can add attribute to HTML element <strong>data-figure-icon=&quot;home&quot;</strong>,
then define in widget&#39;s constructor the option property as <strong>figureIcon</strong>.
During widget instantiate this value will be found. The method search only
attributes defined early as options property.</p>
<pre><code class="lang-mobile(MyWidget-attribute/index.html)">&lt;div class=&quot;my-widget&quot; data-figure-icon=&quot;home&quot;&gt;&lt;/div&gt;
</code></pre>
<h2 id="some-widget-s-option-needs-more-action">Some widget&#39;s option needs more action</h2>
<p>The developer can also define getter and setter for particular option,
just add protected methods with appropriate names.
The method name should be prefixed by <code>_set</code> or <code>_get</code> and contains name of
option property in <strong>camelCase</strong> style.</p>
<p>For example:
<code>_getFigureIcon</code> and <code>_setFigureIcon</code></p>
<pre><code class="lang-js-mobile(MyWidget-configure/index.html)">MyWidget.prototype._getFigureIcon = function () {
    return this.options.figureIcon;
};

MyWidget.prototype._setFigureIcon = function (element, value) {
    // make somethig special before set value
    this.options.figureIcon = value;
};
</code></pre>
<h2 id="how-to-speed-up-the-app">How to speed up the app</h2>
<p>The process of widget build is not parted accidentally. The main idea which
inspired to this solution was exactly the speed up web application start.
The App built based on TAU can be pre built, this mean that all widgets from
the app will built on developer machine and at the moment of app&#39;s start
on device the browser engine will not be wasted time for this.</p>

		</article>

		<footer>
			<div>Licensed under <a href="license.html">MIT License</a> by Samsung Electronics Co., Ltd. &copy;  2014</div>
			<div class="version">ver 0.13.46</div>
		</footer>

		<script src="js/jquery-1.11.1.min.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<script src="js/google-code-prettify/prettify.js"></script>
		<script src="js/smartmenus-0.9.7/jquery.smartmenus.min.js"></script>
		<script src="js/taupreview.js"></script>
		<script>
			$(function () {
				$("#main-menu").smartmenus({
					showOnClick: true
				});
			});
		</script>
	</body>
</html>
